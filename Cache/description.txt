Обоснование выбора структур данных.

	Так как речь идёт о кеше, то подразумевается структура данных максимизирующая  скорость операций с ним. Объекты помещаются в кеш и извлекаютя из него по ключу. Диапазон ключей наперёд не задан, поэтому, я решил хранить ключи и объекты в RedBlackBST(TreeMap в java). Для операций добавления, извлечения, удаления объекта RedBlackBST гаранирует асимптотическую сложность O(log(n)), где n - количество объектов в кеше. Для используемой памяти ассимптотика O(n). Можно было бы воспользоваться хеш-таблицей, так как асимптотика для хеш-функции O(1), но я бы подбирал хеш-функцию имея представление о возможных значениях ключей.

	Стратегия FIFO. В качестве структуры данных для хранения ключей выбрал двусвязный список(в java LinkedList). Сложность O(1), память O(n).

	Стратегия LRU. Для хранения ключей кеша я выбрал индексированную приоритетную очередь(IndexMinPQ), реализованную в виде двоичной кучи. Ключи в очереди проиндексированы. Индекс используется для изменения приоритета ключа объекта.  Неиндексированная приоритетная очереь позволяет добавлять и извлекать ключи с ассимптотической сложностью O(lon(n)), память O(n), где n - количество ключей в очереди, и соостветсвенно объектов в кеше. Индексированная же очередь, помимо добавления и извлечения, позволяет менять приоритет ключа с той же асимптотикой O(log(n)). Что и будет происходить когда мы извлекаем объект из кеша. Для индексированной асимптотика для памяти будет O(capacity), где capacity - заведомо определёный размер кеша. Для сопоставления ключей кеша и его индекса в очереди используется структура CrossTable с асимптотической сложностью O(lon(n)), пямять O(capacity).

Итоговые асимптотики.
FIFO: сложность O(log(n)), память O(n), где n - количество объектов в кеше.
LRU:  сложность O(log(n)), память O(capacity), где capacity - размер кеша.

